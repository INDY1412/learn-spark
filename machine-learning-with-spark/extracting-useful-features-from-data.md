# 從資料中提取有用的特徵

特徵 (features) 指那些用於模型訓練的變量。每一行資料包含可供提取到訓練樣本中的各種訊息。幾乎所有機器學習模型都是與「用向量表示的數值特徵」打交道，因為，需要將原始資料轉換為數值。

> 用向量表示的數值特徵: numerical representations in the form of a vector

特徵分成以下幾種：
- 數值特徵 (numerical features) - 實數或整數，如年齡
- 類別特徵 (categorical features) -  可能狀態集合，如性別、職業
- 文本特徵 (text features) - 延伸自資料的文本內容，如電影名稱、描述、評論
- 其他特徵 - 如影像、視頻、音頻、地理位置(經緯度)

## 數值特徵

機器學習模型中所學習的是各個特徵所對應的向量的權值(a vector of weights for each feature)，使用合理的特徵讓模型能從這些特徵學到特徵值與目標變數間的關係。

## 類別特徵

當類別特徵能為原始形式時，其取直來自所有可能取值所構成的集合，而不是一個數字，因此不能當成輸入。

將類別特徵表示為數字形式，可借用 1-of-k 方法進行。

## 衍生特徵 (Derived features)

從現有的一個或多個變量衍生出新的特徵常常是有幫助的。例如，從原始資料衍生特徵包含計算平均值、中位數、方差、和、差、最大值、最小值、以及計數。

這類轉換背後的想法常常是對數值數據進行某種概括。

數值特徵到類別特徵的轉換也很常見，比如劃分為區間特徵。

source: [src/ex-3.4.ipynb](src/ex-3.4.ipynb)

- 將時間戳記轉為小時
- 再轉換為時間段，得到一個類別特徵
- 透過 1-of-k，可再轉換為二元特徵向量

## 文本特徵

文本特徵處理方式很多。自然語言處理是專注於文本內容的處理、表示、和建模的領域。

Bag-of-word 是一個簡單且標準化的文本處理方式，過程：
- 分詞 (tokenization) - 英文字詞通常可由空白或符號分隔
- 刪除停用詞 (stop words removal) - 移除常見單詞 (the, and, but, ...)
- 提取詞幹 (stemming) - 簡化為基本形式或詞幹 (dogs -> dog)
- 向量化 (vectoriation) - 將處理好的詞用二元向量表示 (使用稀疏矩陣儲存)

## 正則化特徵

將特徵提取為向量形式後，一種常見的預處理方式為將數值數據正則化 (normalization)。背後的思想是將各種數值特徵進行轉換，將他們的值規範到一個標準區間。方式有

- 正則化特徵 - 對資料集中的單個特徵進行轉換
- 正則化特徵向量 - 對資料中的某一行的所有特徵進行轉換，讓轉換後的特徵向量長度標準化

參考 [机器学习中的范数规则化之（一）L0、L1与L2范数](http://blog.csdn.net/zouxy09/article/details/24971995/) 對於范數的解釋：
- 监督机器学习问题无非就是在规则化参数的同时最小化误差
  - 最小化误差是为了让我们的模型拟合我们的训练数据
  - 规则化参数是防止我们的模型过分拟合我们的训练数据
- 训练误差小并不是我们的最终目标，我们的目标是希望模型的测试误差小，也就是能准确的预测新的样本。所以，我们需要保证模型“简单”的基础上最小化训练误差，这样得到的参数才具有好的泛化性能（也就是测试误差也小），而模型“简单”就是通过规则函数来实现的。
- L2范数是指向量各元素的平方和然后求平方根。我们让L2范数的规则项||W||2最小，可以使得W的每个元素都很小，都接近于0
  - 为什么L2范数可以防止过拟合？限制了参数很小，实际上就限制了多项式某些分量的影响很小，这样就相当于减少参数个数。
- L2范数的好处
  - 从学习理论的角度来说，L2范数可以防止过拟合，提升模型的泛化能力。
  - 从优化或者数值计算的角度来说，L2范数有助于处理 condition number不好的情况下矩阵求逆很困难的问题。(让优化求解变得稳定和快速)

### 手動計算正則化的特徵向量

```scala
np.random.seed(42)

x = np.random.randn(10)                             # 返回常態分佈樣本
norm_of_x = np.linalg.norm(x)                       # 計算二階泛數
normalized_x = x / norm_of_x                        # 正則化特徵向量
norm_of_normalized_x = np.linalg.norm(normalized_x) # 計算正則化向量的二階泛數
```

```scala
norm_of_x_by_hand = np.sqrt(reduce(lambda a,b: a+b, map(lambda n: n*n, x)))
```
- 向量各元素的平方和然后求平方根

### 使用 Normalizer 轉換
```scala
from pyspark.mllib.feature import Normalizer

normalizer = Normalizer()
vector = sc.parallelize([x])

normalized_x = normalizer.transform(vector).first().toArray()
```

## 用軟件包提取特徵

借助 scala, java, python 語言言提供的軟件包，使用完善的工具實現特徵的處理與提取，以及向量表示。
